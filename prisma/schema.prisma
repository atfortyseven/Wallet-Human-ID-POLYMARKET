// ============================================================================
// POLYMARKET WALLET - HUMAN-FI ENGINE DATABASE SCHEMA
// ============================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// USER MANAGEMENT
// ============================================================================

model User {
  walletAddress         String   @id
  worldIdNullifierHash  String   @unique
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  // Relations
  proposals             MarketProposal[]
  votes                 ProposalVote[]
  zapTransactions       ZapTransaction[]
  rewardClaims          RewardClaim[]
  metrics               UserMetrics?
}

// ============================================================================
// MARKET PROPOSAL GOVERNANCE
// ============================================================================

model MarketProposal {
  id                String   @id @default(cuid())
  
  // Proposal Details
  question          String
  description       String   @db.Text
  outcomes          Json     // ["Yes", "No"] or multiple outcomes
  resolutionCriteria String  @db.Text
  category          String
  
  // Creator Information
  creatorAddress    String
  creator           User     @relation(fields: [creatorAddress], references: [walletAddress])
  creatorNullifier  String   @unique
  
  // Voting Metrics
  votesFor          Int      @default(0)
  votesAgainst      Int      @default(0)
  votingThreshold   Int      @default(100)
  
  // Status & Lifecycle
  status            ProposalStatus @default(PENDING)
  createdAt         DateTime @default(now())
  votingEndsAt      DateTime
  approvedAt        DateTime?
  marketCreatedAt   DateTime?
  
  // Polymarket Integration
  proposalId        String?  @unique // On-chain bytes32 ID
  polymarketId      String?  @unique
  conditionId       String?
  
  // Royalty Tracking
  totalFeesAccrued  Decimal  @default(0) @db.Decimal(18, 6)
  lastRoyaltyUpdate DateTime @default(now())
  
  // Relations
  votes             ProposalVote[]
  royalties         RoyaltyAccrual[]
  
  // Blockchain Transaction Status
  txStatus          TransactionStatus @default(PENDING_RELAY)
  txHash            String?           @unique
  onChainId         Int?              @unique // ID assigned by Smart Contract

  @@index([status, votingEndsAt])
  @@index([creatorAddress])
  @@index([createdAt])
}

enum TransactionStatus {
  PENDING_RELAY    // Firma recibida, esperando ser enviada a la blockchain
  SUBMITTED        // Enviada a la red, esperando confirmaci√≥n (txHash generado)
  CONFIRMED        // Confirmada en la blockchain (On-chain)
  FAILED           // Revertida o fallo de gas
}

enum ProposalStatus {
  PENDING
  VOTING
  APPROVED
  REJECTED
  CREATED
  RESOLVED
  CANCELLED
}

// ============================================================================
// SYBIL-RESISTANT VOTING
// ============================================================================

model ProposalVote {
  id              String   @id @default(cuid())
  
  // Proposal Reference
  proposalId      String
  proposal        MarketProposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  
  // Voter Identity
  nullifierHash   String
  voterAddress    String
  voter           User     @relation(fields: [voterAddress], references: [walletAddress])
  
  // Vote Details
  vote            VoteChoice
  votedAt         DateTime @default(now())
  
  // World ID Verification
  merkleRoot      String
  proof           Json
  verificationLevel String @default("orb")
  
  // Metadata
  ipfsHash          String?
  
  // Relayer Status
  txHash            String?
  txStatus          TransactionStatus @default(PENDING_RELAY)
  errorMessage      String?
  
  @@unique([proposalId, nullifierHash])
  @@index([proposalId, votedAt])
  @@index([nullifierHash])
}

enum VoteChoice {
  FOR
  AGAINST
  ABSTAIN
}

// ============================================================================
// ROYALTY & REWARD SYSTEM
// ============================================================================

model RoyaltyAccrual {
  id              String   @id @default(cuid())
  
  // Market Reference
  proposalId      String
  proposal        MarketProposal @relation(fields: [proposalId], references: [id])
  
  // Fee Details
  amount          Decimal  @db.Decimal(18, 6)
  feeType         FeeType
  
  // Transaction Context
  txHash          String   @unique
  blockNumber     BigInt
  timestamp       DateTime @default(now())
  
  // Merkle Distribution
  merkleTreeId    String?
  claimed         Boolean  @default(false)
  claimedAt       DateTime?
  claimTxHash     String?
  
  @@index([proposalId, timestamp])
  @@index([merkleTreeId, claimed])
}

enum FeeType {
  TRADING_FEE
  CREATION_FEE
  RESOLUTION_FEE
}

// ============================================================================
// MERKLE TREE DISTRIBUTIONS
// ============================================================================

model MerkleDistribution {
  id              String   @id @default(cuid())
  
  // Distribution Period
  periodStart     DateTime
  periodEnd       DateTime
  
  // Merkle Tree Data
  merkleRoot      String   @unique
  totalAmount     Decimal  @db.Decimal(18, 6)
  
  // IPFS Storage
  ipfsHash        String
  treeData        Json
  
  // Claim Statistics
  totalClaims     Int      @default(0)
  totalClaimed    Decimal  @default(0) @db.Decimal(18, 6)
  
  // Status
  status          DistributionStatus @default(PENDING)
  publishedAt     DateTime?
  expiresAt       DateTime
  
  // Relations
  claims          RewardClaim[]
  
  @@index([periodEnd, status])
}

enum DistributionStatus {
  PENDING
  PUBLISHED
  EXPIRED
  ARCHIVED
}

// ============================================================================
// REWARD CLAIMS
// ============================================================================

model RewardClaim {
  id                String   @id @default(cuid())
  
  // Distribution Reference
  merkleTreeId      String
  distribution      MerkleDistribution @relation(fields: [merkleTreeId], references: [id])
  
  // Claimer
  claimerAddress    String
  claimer           User     @relation(fields: [claimerAddress], references: [walletAddress])
  
  // Claim Details
  amount            Decimal  @db.Decimal(18, 6)
  merkleProof       Json
  leafIndex         Int
  
  // Transaction
  claimedAt         DateTime @default(now())
  txHash            String   @unique
  gasUsed           BigInt
  
  @@unique([merkleTreeId, claimerAddress])
  @@index([claimerAddress, claimedAt])
}

// ============================================================================
// WLD-TO-BET ZAP TRACKING
// ============================================================================

model ZapTransaction {
  id              String   @id @default(cuid())
  
  // User
  userAddress     String
  user            User     @relation(fields: [userAddress], references: [walletAddress])
  
  // Input
  wldAmount       Decimal  @db.Decimal(18, 6)
  wldPriceUSD     Decimal  @db.Decimal(18, 6)
  
  // Swap Details
  usdcReceived    Decimal  @db.Decimal(18, 6)
  slippage        Decimal  @db.Decimal(5, 4)
  dexUsed         String
  
  // Outcome Purchase
  marketId        String
  outcomeIndex    Int
  sharesReceived  Decimal  @db.Decimal(18, 6)
  
  // Transaction Details
  txHash          String   @unique
  blockNumber     BigInt
  gasUsed         BigInt
  gasPaidBy       String
  
  // Status
  status          ZapStatus
  errorMessage    String?
  
  // Timestamps
  initiatedAt     DateTime @default(now())
  completedAt     DateTime?
  
  @@index([userAddress, initiatedAt])
  @@index([status])
}

enum ZapStatus {
  PENDING
  SWAPPING
  BUYING
  COMPLETED
  FAILED
  PARTIAL_FAIL
}

// ============================================================================
// ANALYTICS & METRICS
// ============================================================================

model UserMetrics {
  id                    String   @id @default(cuid())
  
  userAddress           String   @unique
  user                  User     @relation(fields: [userAddress], references: [walletAddress])
  
  // Engagement
  proposalsCreated      Int      @default(0)
  votescast             Int      @default(0)
  zapsExecuted          Int      @default(0)
  
  // Financial
  totalWLDZapped        Decimal  @default(0) @db.Decimal(18, 6)
  totalRoyaltiesEarned  Decimal  @default(0) @db.Decimal(18, 6)
  totalRoyaltiesClaimed Decimal  @default(0) @db.Decimal(18, 6)
  
  // Reputation
  successfulProposals   Int      @default(0)
  reputationScore       Int      @default(0)
  
  // Timestamps
  firstSeenAt           DateTime @default(now())
  lastActiveAt          DateTime @default(now())
  
  @@index([reputationScore])
  @@index([lastActiveAt])
}

